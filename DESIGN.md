# Final Project--Voting via Blockchain--DESIGN.md
### Date: 5/17/21

## Rough Requirements
We are making a music voting mechanism that allows users to vote on whether or not a song should be added to a playlist

#### The Tracker
Shall:
1. Keep track of all nodes who've joined the network and are active
Has track of their public keys. While we did not implement this we assume that the tracker would have some way of verifying a public key
That is maybe each voter registers their public key and proves their identity. Public keys that are not associateed to a proven individual would be denied connection. 
    
2. Send out a poll of a song for clients to vote on. 

#### The Client
Shall:
1. Generate a public/private key pair for session use
2. Take in a desired tracker hostname & port, establish a connection,
	and send its public key to the tracker
3. Read in the peer-to-peer network sent by the tracker, and establish
	a connection with all of the other nodes in the list
4. Query its neighbor nodes for a copy of their current blockchain,
	and keep the copy which is the longest.
5. Provide an interface for the user to input their song choice for
	the current cycle,
	
6. Keep threads open for:
	- listening for new p2p connections
	- listening for peer updates (new blocks & block mining success)
7. As noted above, constantly listen for new blocks from peers. Given
	the data at a block, make an informed choice about whether to add this block to our
	blockchain
8. Allow for both mining and non-mining clients. A non-mining
    client could be used by voters to be able to submit votes without
    having to contribute to the mining effort.
   
   A mining client recieves votes and packages them into blocks to be mined and added to the block chain. 

#### Assumptions
The public/private key generated by a client will not change for
that session. In the future/for a real voting application,
in order to authenticate users, we will rely on a certificate
system/existing public key infrastructure (i.e. voter registration
mechanisms currently in place for public office elections). For
the purposes of this application, we will allow any node which
joins the network to vote.

We should safely assume that the tracker/server program will
always be running before the clients are started. If not,
the clients should cleanly fall out of the tcp connection
attempt.

# Design Specifications
## Assumptions
Assumption:
* network stability/atomic connection time
(if a node recieves data, it can assume it's safe to send to network)

## Inputs and outputs
From the command line, the client will be run with:

`python3 client.py [tracker_address] [tracker_port] [self_port] [mining mode] [mine_time] [key_file]`

Where: 
- `tracker_address` is the ip address of the tracker/server
- `tracker_port` is the port number used by the tracker
- `self_port` is the port # of our own listening socket for p2p connections
- `mining mode` indicates whether the client is willing to mine blocks and
    whether or not the client is able to request specific songs, input as a
    single char: T or F
- `mine_time` is the seconds to wait before pulling from our vote pool and
    beginning to mine a block. By default, 15 seconds.
- `key_file` is the file to store persistent keys between sessions, if desired

Per the assignment requirement, we will use the port numbers assigned
to us for lab 4:
- 60000-60030 (primary)
- 60899-60929
- 60837-60867
- 60868-60898
- 60062-60092

The tracker will be run with:

`python3 tracker.py [listen_port] [hash_padding]`

Where:
- `listen_port` indicates the port # to listen on for incoming connections
- `hash_padding` indicates the number of bits to set to 0 for mining. 50 if not passed in.

## Functional decomposition into modules

Cryptography module: contains submodules which handle
RSA public/private key encryption infrastructure
available for us to use. See `rsa` for the
module in Python.

Hashing module: SHA-256 hashing function. In Python, it's
in `hashlib`

**Primary Process Types**:

*Server/Tracker Application Module*

```
# Maintain network info
# If node joins, update network and send info to node
# If node leaves, update network
```

*Client Application Module*

```
# Main client program
# Handle Mining if needed
# Handle user inputs/votes
```

## Pseudo code (plain English-like language) for logic/algorithmic flow

A user logs onto the application by telling the tracker they have joined and what their public key is and what port they will listen for new connections on. The tracker tells them all the other users and their respective public keys and ports. A client joining is responsible for creating a TCP connection with all prior existining clients. In our toy application this creates a completely connected network. 


We need to files to handle this client.py and tracker.py 
Client can then send a message to all of the other nodes and also communicate with the tracker about leaving. 

*Client Module*

```
Parse command line arguments
Establish connection to tracker

Create p2p connections with peers/neighbors from tracker
Ask for the blockchain from all neighbors

While client is running:
    Continually listen for: 
    - Updates to the chain
    - New neighbors 
 	
    If mining:
    - Listen for new votes to be mined
        Mine current data to try to put out a new block
        If success:
            Flood the block out
	If someone else mines a block before us:
	    terminate mining of current block as its previous hash and potentially entries are outdate
```

*Server/Tracker Module*
```
Parse command line inputs
Establish a listening socket
Upon new connection:
    Add connection to tracker list
    Send client tracker list
Send a poll when told to by command line
Terminate polls when told to by command line 
```


## The Protocol (Application-Level)
In the block data, an entry will be serialized and deserialized
as part of the blockchain. That way, entries/votes will be
in object form for the program to use as necessary. Message types
will be added as needed in the implementation of the application
protocol.

TCP FLAGS:
Flags (used by both client/tracker/miners):
    new -- Used to signify the sending of client port number and public key
Flags (used by client/miners):
    welcome -- Signals that the tracker has sent a list of peers to connect to. 
    update -- Used to signify that the sender would like to update their blockchains, so send your current blockchain and the poll you are on to whoever asked. 
    blockchain -- Receive an incoming blockchain, and the current poll that peer is on
    block -- Receive an incoming block
    entry -- Receive an incoming entry. 
    poll -- Receive a poll from a tracker ( we might join after the poll is initiated, thats why we include the poll in a blockchain update)
    

Command Line Inputs:
Client:
	"TALLY": tallies the current blockchain for a given poll. By default will tally the most recent poll seen. 
	"PRINT": prints out the blockchain 
	"Y": Votes yes for a poll
	"N": Votes no for a poll
	"EXIT": Leaves the program. 

Tracker: 
	"START: {SONG}": Initiates a poll for the given song
	"END" : Terminates the current poll. 
	"EXIT": Leaves the program


## Major data structures
We are following a roughly object-oriented model.

*The "BlockChain"*
```
*a data structure here to hold a list of blocks*

serialize(self){
	returns a serialized version of the blockchain by serializing each block
}
deserialize(self, dataIn){
	takes a properly formatted string in and initializes a blockchain with the passed in data

}

add_block(self, block){
	adds a block to the chain
}

verify_chain(self, padding){
    Recursively call Block.verify and then Entry.verify to verify every block in this chain
    Assure that each block's previous hash references is in fact the hash of the previous block
    Returns True if passes
    False if not. 
}

tally(self, poll){
	Iterate through the blockchain. 
	Keep tallies of the poll by reading every entry of the blockchain 
    Print out the results
}
```

*Entry*

A specific vote sent by a user using their private key.

```
Data
Public Key
Poll_id
Song Vote (Y or N)
Signature
```

Functions
```
getID()
{
    returns the ID of the vote based on the pollId on and person who voted. 

}
sign(privateKey)
{
	 generates signature of entry with the private key
}
verify()
{
	verifies that this signature matches the public key associated with the entry. 
}
```

*Block* 

A collection of Entries.

```
 //Data

Block ID
Nonce
Entries (The Data)
A signature of this block
The hash of the previous block
A link to the previous block
 
 //Functions 
 
sha256() 
{
    SHA256 hash function
}
verify(block_prev, hash_padding)
{
    If not the root block, then we check that every entry is valid
    We check that the previous hash is actually the hash of the previous block in the chain
    We check that hash of this block does in fact pass our hash padding requirement (proof of work)
}

serialize() and deserialize()
```

*Client*

```
JoinChain(Tracker hostname and port number)
{
Creates a TCP connection with a given tracker 
by sending local ip and portnumber and public key 
Receives a list of neighbors from the Tracker
Opens a TCP with each of them and keeps track of that connection and their 
respective public keys
}

LeaveChain(){
Destroy all created connections and tell the Tracker we are leaving
}

ReceieveVote(){
    Listens to a vote from another client. 
    Add this vote to data to be mined upon if I am a mining client 
}
Mine(Nonce){
Calls the block.mine by passing in current votes we have heard and the last nonce we have tried as a starting point. Continually add 1 to nonce until we get a valid block. On completetion sends the finished block to all neighbors. 
}
```

*Tracker*

```
AcceptClient(client){
addClient to dictionary of clients
Send this new client all the other connected clients and their respective keys
}
RemoveClient(client){
take client out of dictionary
}
BroadCastTally(){
Calls GetBlockChain, gets the chain
Then calls tally on the chain
Broadcast's the official tally to all clients (who are free to verify on their own)
}
```

## Testing plan
Unit testing will be done for each new function and class.
This will consist of deterministic tests which verify that known inputs
generate correct outputs. This should be done for every non-trivial
function and should be organized per python file.

As miners and the tracker will be running on the Thayer system, we will 
test integration of components through interactions on the Thayer 
servers. We will conduct input validation, performance testing, and 
integration testing on these servers. 
