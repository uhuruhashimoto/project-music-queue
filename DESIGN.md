# Final Project--Voting via Blockchain--DESIGN.md
### Date: 5/17/21

## Rough Requirements
We are making a music voting mechanism that allows users to vote
on whether or not a song should be added to a playlist/queue

#### The Tracker
Shall:
1. Keep track of all nodes who've joined the network and are active
2. Has track of each user's public keys. While we did not implement,
    this we assume that the tracker would have some way of verifying
    a public key from a separate entity where each voter registers
    their public key and proves their identity. Public keys that are
    not associated to an approved individual would be denied connection
    to the network.    
3. Send out a Y/N poll of a song for clients to vote on.
    - Polls are sent by typing input into the tracker's stdin, which is
        by default interpreted as the name of a song to be voted on.
        The poll is then sent to all clients in the network.
    - Polls are ended when the tracker types `END` into stdin, and all
        clients in the network are alerted to the end of the poll.

#### The Client
Shall:
1. Generate a public/private key pair for session use
2. Take in a desired tracker hostname & port, establish a connection,
	and send its public key to the tracker
3. Read in the peer-to-peer network sent by the tracker, and establish
	a connection with all of the other nodes in the list
4. Query its neighbor nodes for a copy of their current blockchain,
	and keep the copy which is the longest.
5. Provide an interface for the user to input their vote for the
    current poll, and read their vote and send the appropriate
    updates to all peers.
6. The clients will listen for polls from the tracker and fellow peers,
    and they shalltally all votes for the poll so far and print the
    poll results to the user on stdout when they receive an "end poll"
    notification.
7. Keep threads open for:
	- listening for new p2p connections
	- block mining operations on a regular time interval
8. As noted above, constantly listen for new entries from peers. Given
	there are entries not within the blockchain yet when the mining
    timer is hit, mining operations will begin.
9. Allow for both mining and non-mining clients. A non-mining
    client could be used by voters to be able to submit votes without
    having to contribute to the mining effort.
    - A mining client recieves votes and packages them into blocks to
        be mined and added to the block chain.
    - A "regular" client will only send votes out to peers, and not listen
        for incoming votes.
    - All clients will listen for new blocks broadcast to the network, and
        decide whether or not to keep blocks

#### Assumptions
The public/private key generated by a client will not change for
that session. In the future/for a real voting application,
in order to authenticate users, we will rely on a certificate
system/existing public key infrastructure (i.e. voter registration
mechanisms currently in place for public office elections). For
the purposes of this application, we will allow any node which
joins the network to vote.

We should safely assume that the tracker/server program will
always be running before the clients are started. If not,
the clients should cleanly fall out of the tcp connection
attempt.

# Design Specifications
## Assumptions
Assumption:
* network stability/atomic connection time
(if a node recieves data, it can assume it's safe to send to network)

## Inputs and outputs
From the command line, the client will be run with:

`python3 client.py [tracker_address] [tracker_port] [self_port] [mining mode] [mine_time] [key_file]`

Where: 
- `tracker_address` is the ip address of the tracker/server
- `tracker_port` is the port number used by the tracker
- `self_port` is the port # of our own listening socket for p2p connections
- `mining mode` indicates whether the client is willing to mine blocks and
    whether or not the client is able to request specific songs, input as a
    single char: T or F
- `mine_time` is the seconds to wait before pulling from our vote pool and
    beginning to mine a block. By default, 15 seconds.
- `key_file` is the file to store persistent keys between sessions, if desired

Per the assignment requirement, we will use the port numbers assigned
to us for lab 4:
- 60000-60030 (primary)
- 60899-60929
- 60837-60867
- 60868-60898
- 60062-60092

For now, the tracker will be open on 60010 and clients will open 60005 for
peer-2-peer connections.

The tracker will be run with:

`python3 tracker.py [listen_port] [hash_padding]`

Where:
- `listen_port` indicates the port # to listen on for incoming connections
- `hash_padding` indicates the number of bits to set to 0 for mining. 50 if not passed in.

## Functional decomposition into modules

Cryptography module: contains submodules which handle
RSA public/private key encryption infrastructure
available for us to use. See `rsa` for the
module in Python.

Hashing module: SHA-256 hashing function. In Python, it's
in `hashlib`

**Primary Process Types**:

*Server/Tracker Application Module*

```
# Maintain network info
# If node joins, update network and send info to node
# If node leaves, update network
```

*Client Application Module*

```
# Main client program
# Handle Mining if needed
# Handle user inputs/votes
```

## Pseudo code (plain English-like language) for logic/algorithmic flow

A user logs onto the application by telling the tracker they have joined and what their public key is and what port they will listen for new connections on. The tracker tells them all the other users and their respective public keys and ports. A client joining is responsible for creating a TCP connection with all prior existining clients. In our toy application this creates a completely connected network. 


We need to files to handle this client.py and tracker.py 
Client can then send a message to all of the other nodes and also communicate with the tracker about leaving. 

*Client Module*
```
Parse command line arguments
Establish connection to tracker

Create p2p connections with peers/neighbors from tracker
Ask for the blockchain from all neighbors

While client is running:
    Continually listen for: 
    - Updates to the chain
    - New neighbors 
 	
    If mining:
    - Listen for new votes to be mined
        Mine current data to try to put out a new block
        If success:
            Flood the block out
	If someone else mines a block before us:
	    terminate mining of current block as its previous hash and potentially entries are outdate
```

*Server/Tracker Module*
```
Parse command line inputs
Establish a listening socket
Upon new connection:
    Add connection to tracker list
    Send client tracker list
Send a poll when told to by command line
Terminate polls when told to by command line 
```

## The Protocol (Application-Level)
In the block data, an entry will be serialized and deserialized
as part of the blockchain. That way, entries/votes will be
in object form for the program to use as necessary. Message types
will be added as needed in the implementation of the application
protocol.

TCP FLAGS:
Flags (used by both client/tracker/miners):
    new -- Used to signify the sending of client port number and public key
Flags (used by client/miners):
    welcome -- Signals that the tracker has sent a list of peers to connect to. 
    update -- Used to signify that the sender would like to update their blockchains, so send your current blockchain and the poll you are on to whoever asked. 
    blockchain -- Receive an incoming blockchain, and the current poll that peer is on
    block -- Receive an incoming block
    entry -- Receive an incoming entry. 
    poll -- Receive a poll from a tracker ( we might join after the poll is initiated, thats why we include the poll in a blockchain update)
    

Command Line Inputs:
Client:
	"TALLY": tallies the current blockchain for a given poll. By default will tally the most recent poll seen. 
	"PRINT": prints out the blockchain 
	"Y": Votes yes for a poll
	"N": Votes no for a poll
	"EXIT": Leaves the program. 

Tracker: 
	"START: {SONG}": Initiates a poll for the given song
	"END" : Terminates the current poll. 
	"EXIT": Leaves the program


## Major data structures
We are following a roughly object-oriented model.

*The "BlockChain"*
```
*a data structure here to hold a list of blocks*

serialize(self){
	returns a serialized version of the blockchain by serializing each block
}

deserialize(self, dataIn){
	takes a properly formatted string in and initializes a blockchain with the passed in data

}

add_block(self, block){
	adds a block to the chain
}

verify_chain(self, padding){
    Recursively call Block.verify and then Entry.verify to verify every block in this chain
    Assure that each block's previous hash references is in fact the hash of the previous block
    Returns True if passes
    False if not. 
}

tally(self, poll){
	Iterate through the blockchain. 
	Keep tallies of the poll by reading every entry of the blockchain 
    Print out the results
}
```

*Entry*

A specific vote sent by a user using their private key.

```
Data
Public Key
Poll_id
Song Vote ('Y' or 'N')
Signature
```

Functions
```
getID()
{
    returns the ID of the vote based on the pollId on and person who voted. 

}

sign(privateKey)
{
	 generates signature of entry with the private key
}

verify()
{
	verifies that this signature matches the public key associated with the entry. 
}

serialize(self){
	returns a serialized version of the entry 
}

deserialize(self, dataIn){
	takes a properly formatted string in and initializes an entry with the passed data

```

*Block* 

A collection of Entries.

```
 //Data

Block ID
Nonce
Entries (The Data)
A signature of this block
The hash of the previous block
A link to the previous block
 
 //Functions 
 
sha256() 
{
    SHA256 hash function performed on the block
}

verify(block_prev, hash_padding)
{
    If not the root block, then we check that every entry is valid
    We check that the previous hash is actually the hash of the previous block in the chain
    We check that hash of this block does in fact pass our hash padding requirement (proof of work)
}

serialize(self){
	returns a serialized version of the block
}

deserialize(self, dataIn){
	takes a properly formatted string in and initializes a block with given data

```

*Client*

```
openListenSocket(){
    Opens a tcp port for others to connect to, part of setup
}

connectTracker(){
    Creates a tcp connection with the tracker and sends
    our own port and public key, part of setup
}

runClient(){
    main loop of the program that continually calls select to look
    for sockets/inputs to be read from and handle
}

readSocket(socket){
    called by runClient when a socket is read and needs to be handled
}

handleP2PInput(){
    called by readSocket when socket data is coming from the tracker or peer
    data is always assumed to be a json object
    handles each json flag (as discussed in DESIGN.md client flags section)
}

timerThread(){
    On a seperate thread: continually waits a preset amount of time.
    Once timer runs out, it checks self.entries (the entry pool):
    If there are entries, create a block to mine and call mine. Blocks
    on the mining operation until it finishes or receives a new block
    from other peers.
}

mine(block){
    runs a mining operation given a block
    sends out the block if successfully mined and adds the
    block to current blockchain
}

connectToPeers(clientList){
    Given a list of clients from the tracker, create TCP connections with
    all of them and send our public key to them. Run as part of setup.
}

removePeer(socket){
    Remove a peer and close connection if the peer has left.
}

sendToPeers(jsondata){
    Takes some data formatted in json and sends it to all peers.
}

updateBlockchain(blockchain){
    Takes in a new blockchain. if this blockchain is both valid
    and better (longer) than our current one, update our local
    blockchain to be this new blockchain
}

askBlockchain(){
    Broadcast to all peers that we want them to send us their current blockchain
}

displayBlockchain(){
    Prints out current version of blockchain to stdout.
}

receiveBlock(block){
    Determine whether or not a block should be added to our blockchain or discarded
    If the block indicates that a fork has occurred, call askBlockchain
}

receiveEntry(entry){
    If a poll is running and we are mining
    check if a valid entry
    if so add to our entry pool that we mine from
}
recievePoll(poll){
    starts or finishes a poll given by tracker
}

sendVote(voteData){
    creates an entry and sends it to all peers
}

removeFromEntryPool(entries){
    Called when a new block is added to ensure that the client removes any duplicate entries from its local entry pool
}

```

*Tracker*

```
AcceptClient(client){
    addClient to dictionary of clients
    Send this new client all the other connected clients and their respective keys
}

sendClientList(socket){
    Sends the tracker's local client list to a given socket
}

RemoveClient(client){
    Take client out of dictionary
}

readSocket(socket){
    Called by runTracker when a socket is read and needs to be handled
}

handleP2PInput(){
    Called by readSocket when socket data is a json object coming from a client
    handles each json flag (as discussed in DESIGN.md tracker flags section) 
}

runTracker() {
    Main loop of the program that continually calls select to look for sockets/inputs to be read from and handle
}

openListenSocket() {
    Opens a tcp port for others to connect to, part of setup
}
```

## Testing plan
Unit testing will be done for the core block and blockchain methods. 


As miners and the tracker will be running on the Thayer system, we will 
test integration of components through interactions on the Thayer 
servers.
